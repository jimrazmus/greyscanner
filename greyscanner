#!/usr/bin/perl

# Copyright (c) 2006 Bob Beck <beck@openbsd.org>.  All rights reserved.
# Copyright (c) 2009 Jim Razmus II <jim@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use IO::Handle;
use Net::DNS;
use Email::Valid;
use POSIX qw(setsid);
use Sys::Syslog qw(:DEFAULT setlogsock);

use constant {
    STATE     => 0,
    IP        => 1,
    HOST_NAME => 2,
    MAIL_FROM => 3,
    RCPT_TO   => 4,
};

my $SCAN_INTERVAL            = 600;
my $DNS_SOCK_MAX             = 50;
my $SUSPECT_TUPLES           = 5;
my $MAX_DOMAINS              = 3;
my $MAX_SENDERS_RATIO        = 0.75;
my @BAD                      = ();
my @GOOD                     = ();
my $EXTERNAL_ADDRESS_CHECKER = q{};
my $COMPREHENSIVE            = 0;

eval `cat /etc/greyscanner.conf`;

if ( !$ENV{DEBUG} ) {
    chdir '/' or die q{can't chdir to /};
    open STDIN,  '<',  '/dev/null' or die q{can't open /dev/null};
    open STDOUT, '>>', '/dev/null' or die q{can't open /dev/null};
    open STDERR, '>>', '/dev/null' or die q{can't open /dev/null};
    defined( my $pid = fork ) or die "Can't fork: $!";
    exit if ($pid);
    setsid or die "can't setsid: $!";
}

while (1) {
    ### Beginning a Scan

    pipe( READER, WRITER );
    WRITER->autoflush(1);

    my $pid = fork;

    if ( $pid == 0 ) {
        close READER;
        &child;
        close WRITER;
        exit;
    }
    elsif ($pid) {
        close WRITER;
        &parent;
        close READER;
        wait;
    }
    elsif ( not defined $pid ) {
        syslog( 'err', 'Failed to fork' );
        close READER;
        close WRITER;
    }

    ### Scan completed: "Sleeping for $SCAN_INTERVAL secs."
    sleep $SCAN_INTERVAL;
}

exit 0;

sub check_recipients {
    my ($recipients) = @_;
    my $result = 1;

    # XXX: filter for domains we host so we only process "our" email addresses
    my @q = split m/\t/s, $recipients;
    if ( !@q ) {
        $result = 1;
    }
    else {
        foreach my $r (@q) {
            ### Recipient: $r
            foreach (@GOOD) {
                if ( $r =~ $_ ) {
		    $result = 0;
		    last;
		}
            }
            next if $result == 0;
            $COMPREHENSIVE && ( $result = 1 ) && last;
            foreach (@BAD) {
                if ( $r =~ $_ ) {
		    $result = 1;
		    last;
		}
            }
            last if $result == 1;
            if ( -x $EXTERNAL_ADDRESS_CHECKER ) {
                if ( system( ( "$EXTERNAL_ADDRESS_CHECKER", "$r" ) ) != 0 ) {
                    $result = 1;
		    last;
		}
            }
        }
    }
    return $result;
}

sub check_senders {
    my ($senders) = @_;
    my $result = 0;
    my @q = split m/\t/s, $senders;
    if ( !@q ) {
        $result = 'mailed with no sender';
    }
    else {
        foreach my $s (@q) {
            ### Sender: $s
            unless (
                Email::Valid->address(
                    -address     => "$s",
                    -fudge       => 1,
                    -local_rules => 1
                )
              )
            {
                $result = "$s ($Email::Valid::Details)";
                last;
            }
        }
    }
    return $result;
}

sub check_thresholds {
    my ( $senders, $recipients ) = @_;
    my $result = 0;
    my @qr     = split m/\t/s, $recipients;
    my @qs     = split m/\t/s, $senders;
    my $count  = @qs;

    if ( $count > $SUSPECT_TUPLES ) {
        my %R = ();
        my %S = ();
        my %D = ();

        # count the unique senders, recipients, and domains.
        foreach my $r (@qr) {
            $R{"$r"}++;
        }
        foreach my $s (@qs) {
            $S{"$s"}++;
            $s =~ s/[^\@]+\@//;
            $D{"$s"}++;
        }

        my $rcount = keys %R;
        my $scount = keys %S;
        my $dcount = keys %D;

        if ( $dcount > $MAX_DOMAINS ) {
            $result = "sending from $dcount domains (> $MAX_DOMAINS)";
        }
        elsif ( $scount / $count > $MAX_SENDERS_RATIO ) {
            $result = "ratio is $scount/$count (> $MAX_SENDERS_RATIO)";
        }

    }
    return $result;
}

sub child {

    #XXX - drop privs and become _greyscanner

    my %WHITE;
    my %GREY;
    my %TRAPPED;
    my %FROM;
    my %RCPT;
    my %SENDERS;
    my @line;

    open my $spamdb, q{-|}, '/usr/sbin/spamdb' || die q{can't invoke spamdb!};
    while (<$spamdb>) {
        chomp;
        @line = split m/[|]/s;

        if ( $line[STATE] eq 'WHITE' ) {

            $WHITE{"$line[IP]"}++;

        }
        elsif ( $line[STATE] eq 'TRAPPED' ) {

            $TRAPPED{"$line[IP]"}++;

        }
        elsif ( $line[STATE] eq 'GREY' ) {

            $line[MAIL_FROM] =~ s/^<//;
            $line[MAIL_FROM] =~ s/>$//;
            $line[RCPT_TO]   =~ s/^<//;
            $line[RCPT_TO]   =~ s/>$//;

            if ( $GREY{"$line[IP]"} ) {
                $FROM{"$line[IP]"} .= "\t$line[MAIL_FROM]";
                $RCPT{"$line[IP]"} .= "\t$line[RCPT_TO]";
            }
            else {
                $GREY{"$line[IP]"}++;
                $FROM{"$line[IP]"} = "$line[MAIL_FROM]";
                $RCPT{"$line[IP]"} = "$line[RCPT_TO]";
            }

        }

    }
    close $spamdb;

    my $wi = keys %WHITE;
    my $tr = keys %TRAPPED;
    my $gr = keys %GREY;

    ### Loaded: "$wi whitelisted, $tr trapped, $gr unique greys"

    foreach my $grey ( keys %GREY ) {

        ### Analyzing Grey IP: $grey

        ### Ignore if it's already done
        next if ( $TRAPPED{$grey} || $WHITE{$grey} );

        ### Check the recipients.
        if ( &check_recipients( $RCPT{$grey} ) ) {
            print WRITER qq{$grey\t$grey failed recipient check\n};
            $TRAPPED{$grey}++;
        }
        next if $TRAPPED{$grey};

        ### Check the senders.
        if ( my $msg = &check_senders( $FROM{$grey} ) ) {
            print WRITER qq{$grey\t$grey failed sender check\n};
            $TRAPPED{$grey}++;
        }
        next if $TRAPPED{$grey};

        ### Check if host has queued up more than our suspect threshold
        if ( my $msg = &check_thresholds( $RCPT{$grey}, $FROM{$grey} ) ) {
            print WRITER qq{$grey\t$grey failed threshold check: $msg\n};
            $TRAPPED{$grey}++;
        }
        next if $TRAPPED{$grey};

        next if ( !$DNS_SOCK_MAX );    # skip rest if not using DNS checks;

        # finally, we will check for an MX or A record of the source address.
        # first we build a hash of all the senders, keyed by host part
        # of the address, so we only look each host part up once, no matter
        # how many hosts are sending mail with it as the sender.

        my %done = ();
        my @senders = split m/\t/s, $FROM{$grey};
        foreach my $s (@senders) {

            # extract the host part.
            my $h = ( $s =~ /^.*@(.*)$/ ? $1 : $s );
            $h =~ s/\s_+//g;

            if ( !$done{"$h"} ) {
                if ( $SENDERS{$h} ) {
                    $SENDERS{$h} .= "\t $grey";
                }
                else {
                    $SENDERS{$h} = "$grey";
                }
            }
            $done{$h}++;
        }

    }

    if ( !$DNS_SOCK_MAX ) {
        return;
    }

    # DNS sucks moose rocks. So we have to do a bazillion queries in
    # parallel to get any kind of speed. Sigh... Whip through the list of
    # addresses being sent, and validate them by checking for an A or
    # MX record. We don't use Email::Validate because it can't do background
    # queries. instead we use Net::DNS directly and call select..

    my $timeout = 5;
    my $sel     = IO::Select->new;
    my $res     = Net::DNS::Resolver->new;
    my @domains = ( keys %SENDERS );

    while ( scalar @domains > 0 ) {
        my @active = $sel->handles;
        while ( $#active < $DNS_SOCK_MAX - 1 ) {

            # queue up a query for this domain.
            my $d = pop @domains;
            last unless defined $d;
            $sel->add( $res->bgsend( $d, 'A' ) );
            $sel->add( $res->bgsend( $d, 'MX' ) );
            @active = $sel->handles;
        }
        my @ready = $sel->can_read($timeout);
        if (@ready) {
            foreach my $sock (@ready) {
                my $packet = $res->bgread($sock);
                if ( $packet->header->ancount ) {
                    my @q = $packet->question;
                    if ( $q[0]->qtype eq 'A' || $q[0]->qtype eq 'MX' ) {
                        my $d = $q[0]->qname;
                        delete $SENDERS{$d};
                    }
                }

                # Check for the other sockets.
                $sel->remove($sock);
                $sock = undef;
            }
        }
    }
    @domains = undef;

    my $timedout = 0;
    my @ready;
    while ($timedout < 4
        && $sel->handles
        && ( @ready = $sel->can_read($timeout) ) )
    {
        if (@ready) {
            foreach my $sock (@ready) {
                my $packet = $res->bgread($sock);
                if ( $packet->header->ancount ) {
                    my @q = $packet->question;
                    if ( $q[0]->qtype eq 'A' || $q[0]->qtype eq 'MX' ) {
                        my $d = $q[0]->qname;
                        delete $SENDERS{$d};
                    }
                }

                # Check for the other sockets.
                $sel->remove($sock);
                $sock = undef;
            }
        }
        else {
            $timedout++;
        }
    }

    # now whatever is left in %SENDERS is evil - we removed everything
    # we could find a mailer for. We go through the evil addresses
    # and trap anyone sending from one...
    foreach my $evil ( keys %SENDERS ) {
        my @deaders = split m/\t/s, $SENDERS{$evil};
        foreach my $dead (@deaders) {
            print WRITER qq{$dead\tMailed from sender $evil with no MX or A\n};
        }
        @deaders = undef;
    }

    return;
}

sub parent {
    setlogsock('unix');
    openlog( 'greyscanner', 'pid', 'mail' ) || warn q{can't openlog};
    my $line;
    my $ip_regex = '(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';
    while ( $line = <READER> ) {
        chomp $line;
        if ( $line =~ m/^($ip_regex)\t(.*)$/s ) {
            my $ip     = $1;
            my $reason = $2;
            system "/usr/sbin/spamdb -t -a $ip\n";
            syslog( 'info', "Trapped $ip: $reason" );
            ### trapped: "$ip for $reason"
        }
        else {
            syslog( 'info', "Malformed line: $line" );
            ### malformed line: $line
        }
    }
    closelog();
}

__END__

=head1 NAME

greyscanner - Grey trapping daemon for OpenBSD spamd

=head1 SYNOPSIS

B<greyscanner>

=head1 DESCRIPTION

greyscanner complements OpenBSD spamd(8) greylisting by applying
additional heuristics to greylisted hosts.  Additional heuristics
include: confirm senders email address is valid, confirm existence of
the senders MX or A record in DNS, confirm recipient address(es) is
valid, and more.  Offending hosts are flagged as 'trapped' in the spamd
database.

=head1 FILES

F</etc/greyscanner.conf> optional config file

=head1 SEE ALSO

spamd(8), spamdb(8)

=head1 HISTORY

Bob Beck created greyscanner in 2006.  Jim Razmus II revised the
program, added documentation, and packaged it for OpenBSD in 2009.
